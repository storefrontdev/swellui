import * as tracing_1 from "@effect-ts/core/Tracing";
const fileName_1 = "packages/@contentlayer/utils/src/effect/OT.ts";
import { Effect as T, Managed as M, Option as O, pipe } from '@effect-ts/core';
import { pretty } from '@effect-ts/core/Effect/Cause/Pretty';
import * as S from '@effect-ts/core/Effect/Experimental/Stream';
import * as OT from '@effect-ts/otel';
import * as OTApi from '@opentelemetry/api';
export * from '@effect-ts/otel';
export const withStreamSpan = (name, options, ctx) => (stream) => (S.chain_(
// NOTE we're using this weird `S.access` + `S.chain` here since `T.access` seems to be buggy
// TODO fix this with Effect 2 ðŸ¤ 
S.access((r) => r), (r) => (S.unwrapManaged(M.gen(function* ($) {
    const span = yield* $(M.makeExit_((T.succeedWith(() => {
        const { tracer } = OT.Tracer.read(r);
        const maybeSpan = OT.Span.readOption(r);
        if (ctx) {
            return tracer.startSpan(name, options, ctx);
        }
        if (options?.root !== true && O.isSome(maybeSpan)) {
            const ctx = OTApi.trace.setSpan(OTApi.context.active(), maybeSpan.value.span);
            return tracer.startSpan(name, options, ctx);
        }
        return tracer.startSpan(name, { ...options, root: true });
    }, fileName_1 + ":24:32")), (s, e) => T.succeedWith(() => {
        if (e._tag === 'Failure') {
            s.setAttribute('error.type', 'Fiber Failure');
            s.setAttribute('error.message', 'An Effect Has A Failure');
            s.setAttribute('error.stack', pretty(e.cause));
            s.setStatus({ code: OTApi.SpanStatusCode.ERROR });
        }
        else {
            s.setStatus({ code: OTApi.SpanStatusCode.OK });
        }
        s.end();
    }, fileName_1 + ":40:32"), fileName_1 + ":22:26"), fileName_1 + ":21:34");
    return (S.provideAll_(stream, { ...r, ...OT.Span.has(new OT.SpanImpl(span)) }));
})))));
//# sourceMappingURL=OT.js.map