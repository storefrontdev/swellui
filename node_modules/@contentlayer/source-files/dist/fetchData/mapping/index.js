import * as tracing_1 from "@effect-ts/core/Tracing";
const fileName_1 = "packages/@contentlayer/source-files/src/fetchData/mapping/index.ts";
import * as utils from '@contentlayer/utils';
import { identity, pipe, T } from '@contentlayer/utils/effect';
import { FetchDataError } from '../../errors/index.js';
import { getFromDocumentContext } from '../DocumentContext.js';
import { makeDateField } from './field-date.js';
import { makeImageField } from './field-image.js';
import { makeMarkdownField } from './field-markdown.js';
import { makeMdxField } from './field-mdx.js';
import { parseFieldData } from './parseFieldData.js';
export const makeDocument = ({ rawContent, documentTypeDef, coreSchemaDef, relativeFilePath, contentDirPath, options, }) => (T.mapError_(T.gen(function* ($) {
    const { bodyFieldName, typeFieldName } = options.fieldOptions;
    // const includeBody = documentTypeDef.fieldDefs.some(
    //   (_) => _.name === bodyFieldName && _.isSystemField,
    // )
    const body = utils.pattern
        .match(rawContent)
        .when(rawContentHasBody, (_) => _.body)
        .otherwise(() => undefined);
    const rawData = { ...rawContent.fields, [bodyFieldName]: body };
    const docValues = yield* $(T.forEachParDict_(documentTypeDef.fieldDefs, {
        mapValue: (fieldDef) => getDataForFieldDef({
            fieldDef,
            rawFieldData: rawData[fieldDef.name],
            isRootDocument: true,
            coreSchemaDef,
            options,
            documentFilePath: relativeFilePath,
            contentDirPath,
        }),
        mapKey: (fieldDef) => T.succeed(fieldDef.name, fileName_1 + ":63:42"),
    }), fileName_1 + ":51:33");
    const _raw = yield* $(getFromDocumentContext('rawDocumentData'), fileName_1 + ":67:28");
    const doc = {
        ...docValues,
        _id: relativeFilePath,
        _raw,
        [typeFieldName]: documentTypeDef.name,
    };
    return doc;
}, fileName_1 + ":40:10"), (error) => error._tag === 'NoSuchNestedDocumentTypeError' ||
    error._tag === 'IncompatibleFieldDataError' ||
    error._tag === 'ImageError'
    ? error
    : new FetchDataError.UnexpectedError({ error, documentFilePath: relativeFilePath }), fileName_1 + ":78:15"));
const rawContentHasBody = (_) => 'body' in _ && _.body !== undefined;
export const getFlattenedPath = (relativeFilePath) => relativeFilePath
    // remove extension
    .split('.')
    .slice(0, -1)
    .join('.')
    // remove tailing `/index` or `index`
    .replace(/\/?index$/, '');
// TODO aggregate all "global" params into an effect service
const makeNestedDocument = ({ rawObjectData, fieldDefs, nestedTypeName, coreSchemaDef, options, documentFilePath, contentDirPath, }) => T.gen(function* ($) {
    const objValues = yield* $(T.forEachParDict_(fieldDefs, {
        mapValue: (fieldDef) => getDataForFieldDef({
            fieldDef,
            rawFieldData: rawObjectData[fieldDef.name],
            isRootDocument: false,
            coreSchemaDef,
            options,
            documentFilePath,
            contentDirPath,
        }),
        mapKey: (fieldDef) => T.succeed(fieldDef.name, fileName_1 + ":142:40"),
    }), fileName_1 + ":130:31");
    const typeNameField = options.fieldOptions.typeFieldName;
    const obj = { ...objValues, [typeNameField]: nestedTypeName, _raw: {} };
    return obj;
}, fileName_1 + ":129:8");
const getDataForFieldDef = ({ fieldDef, rawFieldData, isRootDocument, coreSchemaDef, options, documentFilePath, contentDirPath, }) => T.gen(function* ($) {
    if ((rawFieldData === undefined || rawFieldData === null) && fieldDef.default !== undefined) {
        rawFieldData = fieldDef.default;
    }
    if (rawFieldData === undefined || rawFieldData === null) {
        const documentTypeDef = yield* $(getFromDocumentContext('documentTypeDef'), fileName_1 + ":175:39");
        console.assert(fieldDef.isRequired === false || fieldDef.isSystemField === true, `Inconsistent data found: ${rawFieldData} ${JSON.stringify({
            fieldDef,
            documentFilePath,
            rootDocTypeName: documentTypeDef.name,
            isRootDocument,
        }, null, 2)}`);
        return rawFieldData;
    }
    const parseFieldDataEff = (fieldType) => parseFieldData({
        rawData: rawFieldData,
        fieldType,
        fieldName: fieldDef.name,
    });
    switch (fieldDef.type) {
        case 'nested': {
            const nestedTypeDef = coreSchemaDef.nestedTypeDefMap[fieldDef.nestedTypeName];
            const rawObjectData = yield* $(parseFieldDataEff('nested'), fileName_1 + ":203:39");
            return yield* $(makeNestedDocument({
                rawObjectData,
                fieldDefs: nestedTypeDef.fieldDefs,
                nestedTypeName: nestedTypeDef.name,
                coreSchemaDef,
                options,
                documentFilePath,
                contentDirPath,
            }), fileName_1 + ":204:24");
        }
        case 'nested_unnamed':
            const rawObjectData = yield* $(parseFieldDataEff('nested_unnamed'), fileName_1 + ":217:39");
            return yield* $(makeNestedDocument({
                rawObjectData,
                fieldDefs: fieldDef.typeDef.fieldDefs,
                nestedTypeName: '__UNNAMED__',
                coreSchemaDef,
                options,
                documentFilePath,
                contentDirPath,
            }), fileName_1 + ":218:24");
        case 'nested_polymorphic': {
            const rawObjectData = yield* $(parseFieldDataEff('nested_polymorphic'), fileName_1 + ":230:39");
            const nestedTypeName = rawObjectData[fieldDef.typeField];
            if (!fieldDef.nestedTypeNames.includes(nestedTypeName)) {
                const documentTypeDef = yield* $(getFromDocumentContext('documentTypeDef'), fileName_1 + ":234:43");
                return yield* $(T.fail(new FetchDataError.NoSuchNestedDocumentTypeError({
                    nestedTypeName,
                    documentFilePath,
                    fieldName: fieldDef.name,
                    validNestedTypeNames: fieldDef.nestedTypeNames,
                    documentTypeDef,
                }), fileName_1 + ":236:19"), fileName_1 + ":235:26");
            }
            const nestedTypeDef = coreSchemaDef.nestedTypeDefMap[nestedTypeName];
            return yield* $(makeNestedDocument({
                rawObjectData,
                fieldDefs: nestedTypeDef.fieldDefs,
                nestedTypeName: nestedTypeDef.name,
                coreSchemaDef,
                options,
                documentFilePath,
                contentDirPath,
            }), fileName_1 + ":250:24");
        }
        case 'reference':
        case 'reference_polymorphic':
            return yield* $(parseFieldDataEff(fieldDef.type), fileName_1 + ":264:24");
        case 'list_polymorphic':
        case 'list':
            const rawListData = yield* $(parseFieldDataEff('list'), fileName_1 + ":267:37");
            return yield* $(T.forEachPar_(rawListData, (rawItemData) => getDataForListItem({
                rawItemData,
                fieldDef,
                coreSchemaDef,
                options,
                documentFilePath,
                contentDirPath,
            }), fileName_1 + ":269:24"), fileName_1 + ":268:24");
        case 'date':
            const dateString = yield* $(parseFieldDataEff('date'), fileName_1 + ":281:36");
            return yield* $(makeDateField({ dateString, fieldName: fieldDef.name, options }), fileName_1 + ":282:24");
        case 'markdown': {
            const mdString = yield* $(parseFieldDataEff('markdown'), fileName_1 + ":284:34");
            const isDocumentBodyField = isRootDocument && fieldDef.name === options.fieldOptions.bodyFieldName;
            return yield* $(makeMarkdownField({ mdString, options, isDocumentBodyField }), fileName_1 + ":286:24");
        }
        case 'mdx': {
            const mdxString = yield* $(parseFieldDataEff('mdx'), fileName_1 + ":289:35");
            return yield* $(makeMdxField({ mdxString, contentDirPath, fieldDef, options }), fileName_1 + ":290:24");
        }
        case 'image':
            const imageData = yield* $(parseFieldDataEff('image'), fileName_1 + ":293:35");
            return yield* $(makeImageField({ imageData, documentFilePath, contentDirPath, fieldDef }), fileName_1 + ":294:24");
        case 'boolean':
        case 'string':
        case 'number':
        case 'json':
        case 'enum': // TODO validate enum value
            return yield* $(parseFieldDataEff(fieldDef.type), fileName_1 + ":300:24");
        default:
            utils.casesHandled(fieldDef);
    }
}, fileName_1 + ":169:8");
export const testOnly_getDataForFieldDef = getDataForFieldDef;
const getDataForListItem = ({ rawItemData, fieldDef, coreSchemaDef, options, documentFilePath, contentDirPath, }) => T.gen(function* ($) {
    const parseFieldDataEff = (fieldType) => parseFieldData({
        rawData: rawItemData,
        fieldType,
        fieldName: fieldDef.name,
    });
    if (fieldDef.type === 'list_polymorphic') {
        const rawObjectData = yield* $(parseFieldDataEff('nested'), fileName_1 + ":332:37");
        const nestedTypeName = rawObjectData[fieldDef.typeField];
        const nestedTypeDef = coreSchemaDef.nestedTypeDefMap[nestedTypeName];
        if (nestedTypeDef === undefined) {
            const validNestedTypeNames = fieldDef.of
                .filter((_) => _.type === 'nested')
                .map((_) => _.nestedTypeName);
            const documentTypeDef = yield* $(getFromDocumentContext('documentTypeDef'), fileName_1 + ":340:41");
            return yield* $(T.fail(new FetchDataError.NoSuchNestedDocumentTypeError({
                nestedTypeName,
                documentFilePath,
                fieldName: fieldDef.name,
                validNestedTypeNames,
                documentTypeDef,
            }), fileName_1 + ":342:17"), fileName_1 + ":341:24");
        }
        return yield* $(makeNestedDocument({
            rawObjectData: rawItemData,
            fieldDefs: nestedTypeDef.fieldDefs,
            nestedTypeName: nestedTypeDef.name,
            coreSchemaDef,
            options,
            documentFilePath,
            contentDirPath,
        }), fileName_1 + ":353:22");
    }
    switch (fieldDef.of.type) {
        case 'nested': {
            const nestedTypeDef = coreSchemaDef.nestedTypeDefMap[fieldDef.of.nestedTypeName];
            const rawObjectData = yield* $(parseFieldDataEff('nested'), fileName_1 + ":369:39");
            return yield* $(makeNestedDocument({
                rawObjectData,
                fieldDefs: nestedTypeDef.fieldDefs,
                nestedTypeName: nestedTypeDef.name,
                coreSchemaDef,
                options,
                documentFilePath,
                contentDirPath,
            }), fileName_1 + ":370:24");
        }
        case 'nested_unnamed': {
            const rawObjectData = yield* $(parseFieldDataEff('nested_unnamed'), fileName_1 + ":383:39");
            return yield* $(makeNestedDocument({
                rawObjectData,
                fieldDefs: fieldDef.of.typeDef.fieldDefs,
                nestedTypeName: '__UNNAMED__',
                coreSchemaDef,
                options,
                documentFilePath,
                contentDirPath,
            }), fileName_1 + ":384:24");
        }
        case 'mdx':
            return makeMdxField({ mdxString: rawItemData, contentDirPath, fieldDef, options });
        case 'date':
            const dateString = yield* $(parseFieldDataEff('date'), fileName_1 + ":399:36");
            return yield* $(makeDateField({ dateString, fieldName: fieldDef.name, options }), fileName_1 + ":400:24");
        case 'markdown': {
            const mdString = yield* $(parseFieldDataEff('markdown'), fileName_1 + ":402:34");
            return yield* $(makeMarkdownField({ mdString, options, isDocumentBodyField: false }), fileName_1 + ":403:24");
        }
        case 'mdx': {
            const mdxString = yield* $(parseFieldDataEff('mdx'), fileName_1 + ":406:35");
            return yield* $(makeMdxField({ mdxString, contentDirPath, fieldDef, options }), fileName_1 + ":407:24");
        }
        case 'image':
            const imageData = yield* $(parseFieldDataEff('image'), fileName_1 + ":410:35");
            return yield* $(makeImageField({ imageData, documentFilePath, contentDirPath, fieldDef }), fileName_1 + ":411:24");
        case 'enum':
        case 'reference':
        case 'string':
        case 'boolean':
        case 'number':
        case 'json':
            return rawItemData;
        default:
            return utils.casesHandled(fieldDef.of);
    }
}, fileName_1 + ":323:8");
//# sourceMappingURL=index.js.map