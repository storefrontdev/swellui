var _a, _b;
import * as tracing_1 from "@effect-ts/core/Tracing";
const fileName_1 = "packages/@contentlayer/core/src/getConfig/esbuild.ts";
import { errorToString } from '@contentlayer/utils';
import { E, Ex, H, M, O, OT, pipe, Q, Ref, S, T, Tagged } from '@contentlayer/utils/effect';
import * as esbuild from 'esbuild';
export const EsbuildWatcherTypeId = Symbol();
export class EsbuildWatcher {
    constructor() {
        this[_a] = EsbuildWatcherTypeId;
    }
}
_a = EsbuildWatcherTypeId;
export class UnknownEsbuildError extends Tagged('UnknownEsbuildError') {
    constructor() {
        super(...arguments);
        this.toString = () => `UnknownEsbuildError: ${errorToString(this.error)}`;
    }
}
export class KnownEsbuildError extends Tagged('KnownEsbuildError') {
    constructor() {
        super(...arguments);
        this.toString = () => `KnownEsbuildError: ${JSON.stringify(this.error, null, 2)}`;
    }
}
class ConcreteEsbuildWatcher {
    constructor(initialBuildResult, buildContext, buildOptions, fsEventsHub) {
        this.initialBuildResult = initialBuildResult;
        this.buildContext = buildContext;
        this.buildOptions = buildOptions;
        this.fsEventsHub = fsEventsHub;
        this[_b] = EsbuildWatcherTypeId;
        this.shutdown = (T.catchAll_(T.chain_(Ref.get(this.buildContext), (buildContext) => T.tryPromise(async () => {
            if (O.isSome(buildContext)) {
                return buildContext.value.dispose();
            }
            else {
                throw new Error(`This should never happen. Esbuild build context is not set.`);
            }
        }, fileName_1 + ":40:19"), fileName_1 + ":39:12"), (_) => T.unit, fileName_1 + ":48:15"));
        this.start = (T.catchAll_(OT.withSpan('esbuild:start', { attributes: { buildOptions: JSON.stringify(this.buildOptions) } })(T.suspend(() => {
            const { fsEventsHub, buildOptions, initialBuildResult } = this;
            const self = this; // eslint-disable-line @typescript-eslint/no-this-alias
            return T.gen(function* ($) {
                const runtime = yield* $(T.runtime(), fileName_1 + ":56:33");
                const buildWatchPlugin = {
                    name: 'contentlayer-watch-plugin',
                    setup(build) {
                        let isFirstBuild = false;
                        build.onEnd((result) => {
                            runtime.runFiber(OT.addEvent('esbuild-build-result', { result: JSON.stringify(result) }));
                            if (isFirstBuild) {
                                isFirstBuild = false;
                            }
                            else {
                                if (result.errors.length > 0) {
                                    runtime.runFiber(H.publish_(fsEventsHub, Ex.succeed(E.left(new KnownEsbuildError({ error: result.errors })))));
                                }
                                else {
                                    runtime.runFiber(H.publish_(fsEventsHub, Ex.succeed(E.right(result))));
                                }
                            }
                        });
                    },
                };
                const buildContext = yield* $(T.tryCatchPromise(() => esbuild.context({
                    ...buildOptions,
                    plugins: [buildWatchPlugin, ...(buildOptions.plugins ?? [])],
                }), (error) => new UnknownEsbuildError({ error }), fileName_1 + ":82:28"), fileName_1 + ":81:38");
                yield* $(Ref.set_(self.buildContext, O.some(buildContext)), fileName_1 + ":92:17");
                yield* $(T.tryCatchPromise(
                // TODO remove `async` once `watch()` returns a Promise (bug in esbuild)
                async () => buildContext.watch(), (error) => new UnknownEsbuildError({ error }), fileName_1 + ":95:28"), fileName_1 + ":94:17");
                yield* $((OT.withSpan('esbuild:initial-rebuild')(T.tap_(T.tap_(T.tryCatchPromise(() => buildContext.rebuild(), (error) => new UnknownEsbuildError({ error }), fileName_1 + ":104:30"), (res) => Ref.set_(initialBuildResult, O.some(res)), fileName_1 + ":108:18"), (res) => H.publish_(fsEventsHub, Ex.succeed(E.right(res))), fileName_1 + ":109:18"))), fileName_1 + ":102:17");
            }, fileName_1 + ":55:19");
        }, fileName_1 + ":52:14")), (error) => H.publish_(this.fsEventsHub, Ex.succeed(E.left(error))), fileName_1 + ":116:15"));
        this.subscribe = (M.map_(M.chain_(H.subscribe(this.fsEventsHub), (_) => M.ensuringFirst_(M.succeed(S.fromQueue()(_), fileName_1 + ":121:46"), Q.shutdown(_), fileName_1 + ":121:36"), fileName_1 + ":121:12"), S.flattenExit, fileName_1 + ":122:10"));
    }
}
_b = EsbuildWatcherTypeId;
function concrete(esbuildWatcher) {
    //
}
export const make = (buildOptions) => T.gen(function* ($) {
    const initialBuildResult = yield* $(Ref.makeRef(O.none), fileName_1 + ":132:40");
    const hub = yield* $(H.makeUnbounded(), fileName_1 + ":133:25");
    const buildContext = yield* $(Ref.makeRef(O.none), fileName_1 + ":134:34");
    return new ConcreteEsbuildWatcher(initialBuildResult, buildContext, buildOptions, hub);
}, fileName_1 + ":131:8");
export const subscribe = (self) => {
    concrete(self);
    return self.subscribe;
};
const start = (self) => {
    concrete(self);
    return self.start;
};
// export const makeAndSubscribeManaged = (
//   buildOptions: esbuild.BuildOptions,
// ): M.Managed<unknown, UnknownEsbuildError, S.Stream<unknown, never, E.Either<EsbuildError, esbuild.BuildResult>>> =>
//   pipe(M.make_(make(buildOptions), shutdown), M.chain(subscribe))
export const makeAndSubscribeManaged = (buildOptions) => (M.chain_(M.make_(make(buildOptions), shutdown, fileName_1 + ":162:12"), (esbuildWatcher) => (M.tap_(subscribe(esbuildWatcher), () => T.toManaged(start(esbuildWatcher)), fileName_1 + ":166:14")), fileName_1 + ":163:12"));
export const makeAndSubscribe = (buildOptions) => (S.unwrapManaged(makeAndSubscribeManaged(buildOptions)));
export const shutdown = (self) => {
    concrete(self);
    return self.shutdown;
};
//# sourceMappingURL=esbuild.js.map